pipeline {
  agent any
  options { timestamps(); ansiColor('xterm'); durabilityHint('PERFORMANCE_OPTIMIZED'); timeout(time: 90, unit: 'MINUTES') }

  parameters {
    string(name: 'BRANCH', defaultValue: 'master', description: 'Ветка деплоя')
    string(name: 'REPO', defaultValue: 'https://github.com/thunder-ss14/corporate-war.git', description: 'Git repo (https или ssh)')
    string(name: 'SERVER_DOMAIN', defaultValue: 'thunderhub.online', description: 'Домен для ссылки в манифесте')

    credentials(name: 'SSH_CRED',
      description: 'ID=host (IP/DNS), Username+Key',
      defaultValue: '88.99.104.199',
      credentialType: 'com.cloudbees.jenkins.plugins.sshcredentials.impl.BasicSSHUserPrivateKey')
}

  environment {
    DOTNET_CLI_TELEMETRY_OPTOUT = '1'
    GIT_TERMINAL_PROMPT = '0'
    MSBUILDDISABLENODEREUSE = '1'
    DOTNET_CLI_HOME = "${WORKSPACE}/.dotnet_home"
    MSBUILDDEBUGPATH = "${WORKSPACE}/msbuild-logs"
  }

  stages {
    stage('Checkout') {
      steps {
        withCredentials([string(credentialsId: 'token-github', variable: 'GITHUB_TOKEN')]) {
          sh '''#!/usr/bin/env bash
BRANCH="${BRANCH:-${BRANCH_NAME:-master}}"
REPO="${REPO:-${GIT_URL:-}}"
[ -n "$REPO" ] || REPO="$(git -C "$WORKSPACE" remote get-url origin 2>/dev/null || true)"
[ -n "$REPO" ] || { echo "REPO не определён"; exit 1; }

set -euo pipefail
rm -rf src
cat > askpass.sh <<'EOS'
#!/bin/sh
case "$1" in
  *Username*) echo "x-access-token" ;;
  *Password*) echo "$GITHUB_TOKEN" ;;
esac
EOS
chmod +x askpass.sh
GIT_ASKPASS="$PWD/askpass.sh" GIT_ASKPASS_REQUIRE=force git clone --depth 1 -b "$BRANCH" "$REPO" src
GIT_ASKPASS="$PWD/askpass.sh" GIT_ASKPASS_REQUIRE=force git -C src -c url.https://github.com/.insteadof=git@github.com: submodule update --init --recursive
git -C src config --local safe.directory "$(pwd)/src" || true
'''
        }
      }
    }

    stage('Install .NET') {
      steps {
        sh '''#!/usr/bin/env bash
set -euo pipefail
mkdir -p .dotnet "$DOTNET_CLI_HOME" "$MSBUILDDEBUGPATH"
curl -fsSL https://dot.net/v1/dotnet-install.sh -o dotnet-install.sh
bash dotnet-install.sh --install-dir "$PWD/.dotnet" --channel 9.0
export PATH="$PWD/.dotnet:$PATH"
dotnet --info
'''
      }
    }

    stage('Restore & Build') {
      steps {
        sh '''#!/usr/bin/env bash
set -Eeuo pipefail
export PATH="$PWD/.dotnet:$PATH"
cd src
dotnet restore
dotnet build Content.Packaging --configuration Release -v minimal -m:1 -p:UseSharedCompilation=false
dotnet run --project Content.Packaging server --hybrid-acz --platform linux-x64
'''
      }
    }

    stage('Package ZIP + Manifest') {
      steps {
        sh '''#!/usr/bin/env bash
set -Eeuo pipefail
rm -rf artifact publish
mkdir -p artifact publish

# 1) Сначала пробуем готовый ZIP от Content.Packaging
ZIP_FILE="$(ls -1 src/release/SS14.Server*_linux-x64.zip src/release/*Server*_linux-x64.zip 2>/dev/null | head -n1 || true)"
if [ -n "$ZIP_FILE" ]; then
  echo "Найден готовый ZIP: $ZIP_FILE"
  cp "$ZIP_FILE" SS14.Server_linux-x64.zip
else
  # 2) Фолбэк: ищем выложенную директорию с Robust.Server и пакуем сами
  OUTDIR="$(find src/release -maxdepth 4 -type f -name Robust.Server -printf '%h\\n' -quit || true)"
  if [ -z "$OUTDIR" ]; then
    echo "❌ Не найдена сборка в src/release"
    ls -la src/release || true
    exit 1
  fi
  echo "Найден OUTDIR: $OUTDIR"
  rsync -a --delete "$OUTDIR"/ artifact/
  ( cd artifact && zip -r ../SS14.Server_linux-x64.zip . )
fi

# Хэш и время для манифеста
SHA256="$(sha256sum SS14.Server_linux-x64.zip | awk '{print $1}')"
BUILD_TIME="$(date -u +'%Y-%m-%dT%H:%M:%SZ')"

# owner/repo из REPO
repo_path="$(printf '%s' "${REPO}" | sed -E 's#(git@github.com:|https://github.com/)([^/]+/[^/.]+)(\\.git)?#\\2#')"
repo="${repo_path##*/}"

ZIP_NAME="SS14.Server_linux-x64.zip"
MANIFEST_NAME="manifest.json"
DOWNLOAD_URL="https://${SERVER_DOMAIN}/ss14/${repo}/${ZIP_NAME}"

cat > "${MANIFEST_NAME}" <<EOF
{
  "builds": {
    "${BUILD_TIME}": {
      "time": "${BUILD_TIME}",
      "server": {
        "linux-x64": {
          "url": "${DOWNLOAD_URL}",
          "sha256": "${SHA256}"
        }
      }
    }
  }
}
EOF

mv "${MANIFEST_NAME}" publish/
mv "${ZIP_NAME}" publish/
'''
        archiveArtifacts artifacts: 'publish/*', fingerprint: true
      }
    }

    stage('Publish to HTTP') {
      steps {
        withCredentials([sshUserPrivateKey(credentialsId: params.SSH_CRED, keyFileVariable: 'SSH_KEY', usernameVariable: 'SSH_USER')]) {
          sh '''#!/usr/bin/env bash
set -Eeuo pipefail
HOST_HOST="${SSH_CRED}"
SSH_OPTS="-o StrictHostKeyChecking=no -o ServerAliveInterval=30 -o ServerAliveCountMax=120 -i \"$SSH_KEY\""
repo_path="$(printf '%s' "${REPO}" | sed -E 's#(git@github.com:|https://github.com/)([^/]+/[^/.]+)(\\.git)?#\\2#')"
repo="${repo_path##*/}"
WEB_DIR="/var/www/html/ss14/${repo}"
HOST="$SSH_USER@$HOST_HOST"

ssh $SSH_OPTS "$HOST" "sudo mkdir -p '${WEB_DIR}' && sudo chown -R ${SSH_USER}:${SSH_USER} '${WEB_DIR}'"
rsync -av -e "ssh $SSH_OPTS" publish/ "$HOST:${WEB_DIR}/"
ssh $SSH_OPTS "$HOST" "ls -la '${WEB_DIR}'"
'''
        }
      }
    }

    stage('Control (optional)') {
      when { expression { return params.ACTION != null && params.ACTION.trim() != '' } }
      steps {
        withCredentials([sshUserPrivateKey(credentialsId: params.SSH_CRED, keyFileVariable: 'SSH_KEY', usernameVariable: 'SSH_USER')]) {
          sh '''#!/usr/bin/env bash
set -Eeuo pipefail
HOST_HOST="${SSH_CRED}"
SSH_OPTS="-o StrictHostKeyChecking=no -i \"$SSH_KEY\""
HOST="$SSH_USER@$HOST_HOST"

case "${ACTION}" in
  status)
    ssh $SSH_OPTS "$HOST" /bin/bash -lc '
      set -e
      nginx -v 2>&1 || true
      echo "WEB roots under /var/www/html/ss14:"
      ls -la /var/www/html/ss14 || true
    '
    ;;
  start|stop|restart)
    echo "ACTION=${ACTION} задан, управление сервисами вне этого пайпа."
    ;;
  *)
    echo "ACTION=${ACTION} не распознан";;
esac
'''
        }
      }
    }
  }

  post {
    always { archiveArtifacts artifacts: 'msbuild-logs/**', allowEmptyArchive: true }
    success { echo '✅ ZIP и manifest выложены для Watchdog.' }
    failure { echo '❌ Pipeline failed.' }
  }
}

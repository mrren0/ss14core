pipeline {
  agent any
  options { timestamps(); ansiColor('xterm'); durabilityHint('PERFORMANCE_OPTIMIZED'); timeout(time: 90, unit: 'MINUTES') }

  parameters {
    string(name: 'BRANCH', defaultValue: 'master', description: 'Ветка деплоя')
    string(name: 'REPO', defaultValue: 'https://github.com/thunder-ss14/corporate-war.git', description: 'Git repo (https или ssh)')
    string(name: 'SERVER_DOMAIN', defaultValue: 'thunderhub.online', description: 'Домен для ссылки в манифесте')

    // Твои «хитрые» параметры
    credentials(name: 'SSH_CRED',
      description: 'ID=host (IP/DNS), Username+Key',
      defaultValue: '88.99.104.199',
      credentialType: 'com.cloudbees.jenkins.plugins.sshcredentials.impl.BasicSSHUserPrivateKey')
    choice(name: 'ACTION', choices: ['status','stop','start','restart'], description: 'Действие')
    string(name: 'TARGET', defaultValue: '', description: 'Опц.: ss14*.service или :PORT или #TAG')
  }

  environment {
    DOTNET_CLI_TELEMETRY_OPTOUT = '1'
    GIT_TERMINAL_PROMPT = '0'
    MSBUILDDISABLENODEREUSE = '1'
    DOTNET_CLI_HOME = "${WORKSPACE}/.dotnet_home"
    MSBUILDDEBUGPATH = "${WORKSPACE}/msbuild-logs"
  }

  stages {
    stage('Checkout') {
      steps {
        withCredentials([string(credentialsId: 'token-github', variable: 'GITHUB_TOKEN')]) {
          sh '''#!/usr/bin/env bash
set -euo pipefail
rm -rf src
cat > askpass.sh <<'EOS'
#!/bin/sh
case "$1" in
  *Username*) echo "x-access-token" ;;
  *Password*) echo "$GITHUB_TOKEN" ;;
esac
EOS
chmod +x askpass.sh
GIT_ASKPASS="$PWD/askpass.sh" GIT_ASKPASS_REQUIRE=force git clone --depth 1 -b "$BRANCH" "$REPO" src
GIT_ASKPASS="$PWD/askpass.sh" GIT_ASKPASS_REQUIRE=force git -C src -c url.https://github.com/.insteadof=git@github.com: submodule update --init --recursive
git -C src config --local safe.directory "$(pwd)/src" || true
'''
        }
      }
    }

    stage('Install .NET') {
      steps {
        sh '''#!/usr/bin/env bash
set -euo pipefail
mkdir -p .dotnet "$DOTNET_CLI_HOME" "$MSBUILDDEBUGPATH"
curl -fsSL https://dot.net/v1/dotnet-install.sh -o dotnet-install.sh
bash dotnet-install.sh --install-dir "$PWD/.dotnet" --channel 9.0
export PATH="$PWD/.dotnet:$PATH"
dotnet --info
'''
      }
    }

    stage('Restore & Build') {
      steps {
        sh '''#!/usr/bin/env bash
set -Eeuo pipefail
export PATH="$PWD/.dotnet:$PATH"
cd src
dotnet restore
dotnet build Content.Packaging --configuration Release -v minimal -m:1 -p:UseSharedCompilation=false
dotnet run --project Content.Packaging server --hybrid-acz --platform linux-x64
'''
      }
    }

    stage('Package ZIP + Manifest') {
      steps {
        sh '''#!/usr/bin/env bash
set -Eeuo pipefail
rm -rf artifact publish
mkdir -p artifact publish

OUTDIR="$(find src/release -maxdepth 4 -type f -name Robust.Server -printf '%h\\n' -quit || true)"
[ -z "$OUTDIR" ] && { echo "❌ Не найдена сборка"; exit 1; }
rsync -a --delete "$OUTDIR"/ artifact/

pushd artifact >/dev/null
zip -r ../SS14.Server_linux-x64.zip .
popd >/dev/null

SHA256="$(sha256sum SS14.Server_linux-x64.zip | awk '{print $1}')"
BUILD_TIME="$(date -u +'%Y-%m-%dT%H:%M:%SZ')"

repo_path="$(printf '%s' "${REPO}" | sed -E 's#(git@github.com:|https://github.com/)([^/]+/[^/.]+)(\\.git)?#\\2#')"
repo="${repo_path##*/}"
ZIP_NAME="SS14.Server_linux-x64.zip"
MANIFEST_NAME="manifest.json"
DOWNLOAD_URL="https://${SERVER_DOMAIN}/ss14/${repo}/${ZIP_NAME}"

cat > "${MANIFEST_NAME}" <<EOF
{
  "builds": {
    "${BUILD_TIME}": {
      "time": "${BUILD_TIME}",
      "server": {
        "linux-x64": {
          "url": "${DOWNLOAD_URL}",
          "sha256": "${SHA256}"
        }
      }
    }
  }
}
EOF

mv "${MANIFEST_NAME}" publish/
mv "${ZIP_NAME}" publish/
'''
        archiveArtifacts artifacts: 'publish/*', fingerprint: true
      }
    }

    stage('Publish to HTTP') {
      steps {
        // ВАЖНО: host не склеиваем в Groovy. Передаём HOST_HOST и собираем user@host в bash.
        withCredentials([sshUserPrivateKey(credentialsId: params.SSH_CRED, keyFileVariable: 'SSH_KEY', usernameVariable: 'SSH_USER')]) {
          sh '''#!/usr/bin/env bash
set -Eeuo pipefail
HOST_HOST="${SSH_CRED}"   # ID параметра = DNS/IP хоста
SSH_OPTS="-o StrictHostKeyChecking=no -o ServerAliveInterval=30 -o ServerAliveCountMax=120 -i \"$SSH_KEY\""
repo_path="$(printf '%s' "${REPO}" | sed -E 's#(git@github.com:|https://github.com/)([^/]+/[^/.]+)(\\.git)?#\\2#')"
repo="${repo_path##*/}"
WEB_DIR="/var/www/html/ss14/${repo}"
HOST="$SSH_USER@$HOST_HOST"

ssh $SSH_OPTS "$HOST" "sudo mkdir -p '${WEB_DIR}' && sudo chown -R ${SSH_USER}:${SSH_USER} '${WEB_DIR}'"
rsync -av -e "ssh $SSH_OPTS" publish/ "$HOST:${WEB_DIR}/"
ssh $SSH_OPTS "$HOST" "ls -la '${WEB_DIR}'"
'''
        }
      }
    }

    // Опционально: управляющий шаг под твои ACTION/TARGET. Ничего критичного не делает, просто пример.
    stage('Control (optional)') {
      when { expression { return params.ACTION != null && params.ACTION.trim() != '' } }
      steps {
        withCredentials([sshUserPrivateKey(credentialsId: params.SSH_CRED, keyFileVariable: 'SSH_KEY', usernameVariable: 'SSH_USER')]) {
          sh '''#!/usr/bin/env bash
set -Eeuo pipefail
HOST_HOST="${SSH_CRED}"
SSH_OPTS="-o StrictHostKeyChecking=no -i \"$SSH_KEY\""
HOST="$SSH_USER@$HOST_HOST"

# Пример: показать статус раздачи артефактов и версию nginx
case "${ACTION}" in
  status)
    ssh $SSH_OPTS "$HOST" /bin/bash -lc '
      set -e
      nginx -v 2>&1 || true
      echo "WEB roots under /var/www/html/ss14:"
      ls -la /var/www/html/ss14 || true
    '
    ;;
  start|stop|restart)
    echo "ACTION=${ACTION} задан, но управление сервисами опущено в этом пайплайне."
    ;;
  *)
    echo "ACTION=${ACTION} не распознан";;
esac
'''
        }
      }
    }
  }

  post {
    always { archiveArtifacts artifacts: 'msbuild-logs/**', allowEmptyArchive: true }
    success { echo '✅ ZIP и manifest выложены для Watchdog.' }
    failure { echo '❌ Pipeline failed.' }
  }
}

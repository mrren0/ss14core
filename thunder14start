pipeline {
  agent any
  options { timestamps(); ansiColor('xterm'); durabilityHint('PERFORMANCE_OPTIMIZED'); timeout(time: 90, unit: 'MINUTES') }

  parameters {
    string(name: 'SSH_CREDENTIALS_ID', defaultValue: '162.19.232.192', description: 'ID SSH credentials в Jenkins')
    string(name: 'SERVER_IP', defaultValue: '162.19.232.192', description: 'IP адрес сервера')

    string(name: 'BRANCH', defaultValue: 'master', description: 'Ветка деплоя')
    string(name: 'REPO', defaultValue: 'https://github.com/thunder-ss14/corporate-war.git', description: 'Git repo (https или ssh)')

    // Новые параметры для конфига: либо файл, либо текст
    string(name: 'CFG_FILE', defaultValue: '', description: 'Путь к server_config.toml в workspace (относительный). Приоритет у CFG_FULL.')
    text(name: 'CFG_FULL', defaultValue: '', description: 'Полное содержимое server_config.toml. Имеет приоритет над CFG_FILE.')
  }

  environment {
    DOTNET_CLI_TELEMETRY_OPTOUT = '1'
    GIT_TERMINAL_PROMPT = '0'
    MSBUILDDISABLENODEREUSE = '1'
    DOTNET_CLI_HOME = "${WORKSPACE}/.dotnet_home"
    MSBUILDDEBUGPATH = "${WORKSPACE}/msbuild-logs"
    // Генерируем имя репозитория для путей
    REPO_NAME = "${params.REPO}".replaceAll('.*/', '').replaceAll(/\\.git$/, '')
  }

  stages {
    stage('Prepare Config') {
      steps {
        script {
          // Приоритет у текстового поля CFG_FULL
          if (params.CFG_FULL?.trim()) {
            echo "Using config from text field (CFG_FULL)."
            writeFile(file: 'server_config.toml', text: params.CFG_FULL)
          }
          // Если текста нет, пробуем взять файл
          else if (params.CFG_FILE?.trim()) {
            def sourceFile = file(params.CFG_FILE)
            if (sourceFile.exists()) {
              echo "Using config from file: ${params.CFG_FILE}"
              sh "cp '${sourceFile}' '${WORKSPACE}/server_config.toml'"
            } else {
              error "Configuration error: File ${params.CFG_FILE} not found in workspace."
            }
          }
          // Если ничего не передали - это ошибка
          else {
            error "Configuration error: Either 'CFG_FILE' or 'CFG_FULL' must be provided."
          }

          // Парсим PORT из конфига для последующих шагов
          sh '''#!/usr/bin/env bash
            set +e # Важно: отключаем fail на этом шаге, если awk не найдет порт
            awk -F= '
            /^[[:space:]]*port[[:space:]]*=/ {
                # Убираем пробелы, табы, кавычки любого типа, комментарии
                gsub(/[ \\t"\\047]/, "", $2);
                sub(/#.*/, "", $2);
                if ($2 ~ /^[0-9]+$/) {
                    print $2;
                    exit;
                }
            }' server_config.toml > .port
            set -e

            # Проверяем, получили ли мы порт, если нет - ставим дефолтный
            if [ -s .port ]; then
                echo "PORT extracted from config: $(cat .port)"
            else
                echo "WARNING: Could not find 'port' in server_config.toml. Using default 1212."
                echo "1212" > .port
            fi
          '''
          // Читаем порт в переменную Jenkins
          PORT = sh(script: 'cat .port', returnStdout: true).trim()
        }
      }
    }

    stage('Checkout + Submodules') {
      steps {
        withCredentials([string(credentialsId: 'token-github', variable: 'GITHUB_TOKEN')]) {
          sh '''#!/usr/bin/env bash
            set -euo pipefail
            rm -rf src
            cat > askpass.sh <<'EOS'
            #!/bin/sh
            case "$1" in
              *Username*) echo "x-access-token" ;;
              *Password*) echo "$GITHUB_TOKEN" ;;
            esac
            EOS
            chmod +x askpass.sh
            GIT_ASKPASS="$PWD/askpass.sh" GIT_ASKPASS_REQUIRE=force git clone --depth 1 -b "$BRANCH" "$REPO" src
            GIT_ASKPASS="$PWD/askpass.sh" GIT_ASKPASS_REQUIRE=force git -C src -c url.https://github.com/.insteadof=git@github.com: submodule update --init --recursive
            git -C src config --local safe.directory "$(pwd)/src" || true
          '''
        }
      }
    }

    stage('.NET SDK (local)') {
      steps {
        sh '''#!/usr/bin/env bash
          set -euo pipefail
          mkdir -p .dotnet "$DOTNET_CLI_HOME" "$MSBUILDDEBUGPATH"
          curl -fsSL --retry 8 --retry-all-errors --retry-delay 2 -o dotnet-install.sh https://dot.net/v1/dotnet-install.sh
          bash dotnet-install.sh --install-dir "$PWD/.dotnet" --channel 9.0
          export PATH="$PWD/.dotnet:$PATH"
          dotnet --info
        '''
      }
    }

    stage('Restore (retry)') {
      steps {
        sh '''#!/usr/bin/env bash
          set -Eeuo pipefail
          export PATH="$PWD/.dotnet:$PATH"
          cd src
          dotnet nuget locals all --clear || true
          for i in 1 2 3; do
            stdbuf -oL -eL dotnet restore --no-cache && s=0 && break || s=$?
            echo "restore retry $i failed with $s"; sleep $((5*i))
          done
          [ "${s:-0}" -eq 0 ]
        '''
      }
    }

    stage('Build & Package') {
      steps {
        retry(2) {
          sh '''#!/usr/bin/env bash
            set -Eeuo pipefail
            export PATH="$PWD/.dotnet:$PATH"
            cd src
            ( while true; do echo "[keepalive] $(date -Iseconds) build alive"; sleep 55; done ) & KA=$!
            trap 'kill $KA 2>/dev/null || true; dotnet build-server shutdown || true' EXIT
            stdbuf -oL -eL dotnet build Content.Packaging --configuration Release -v minimal -m:1 -p:UseSharedCompilation=false
            stdbuf -oL -eL dotnet run --project Content.Packaging server --hybrid-acz --platform linux-x64
          '''
        }
      }
    }

    stage('Archive artifact') {
      steps {
        sh '''#!/usr/bin/env bash
          set -euo pipefail
          rm -rf artifact
          mkdir -p artifact
          OUTDIR="$(find src/release -maxdepth 4 -type f -name Robust.Server -printf '%h\\n' -quit || true)"
          if [ -n "$OUTDIR" ]; then
            rsync -a --delete --exclude=".git" "$OUTDIR"/ artifact/
          else
            ZIP_FILE="$(ls -1 src/release/SS14.Server*_linux-x64.zip src/release/SS14.Server*.zip 2>/dev/null | head -n1 || true)"
            if [ -z "$ZIP_FILE" ]; then
              echo "❌ Нет сборки в src/release"
              ls -la src/release || true
              exit 1
            fi
            unzip -o "$ZIP_FILE" -d artifact/
            [ -f artifact/Robust.Server ] && chmod +x artifact/Robust.Server || true
          fi
          tar -C artifact -czf "ss14-server-${BRANCH}.tar.gz" .
        '''
        archiveArtifacts artifacts: "ss14-server-${BRANCH}.tar.gz", fingerprint: true
      }
    }

    stage('Ensure .NET 9 runtime on target') {
      steps {
        withCredentials([sshUserPrivateKey(credentialsId: params.SSH_CREDENTIALS_ID, keyFileVariable: 'SSH_KEY', usernameVariable: 'SSH_USER')]) {
          sh '''#!/usr/bin/env bash
            set -Eeuo pipefail
            SSH_OPTS="-o StrictHostKeyChecking=no -o ServerAliveInterval=30 -o ServerAliveCountMax=120 -i \"$SSH_KEY\""

            if ssh $SSH_OPTS "${SSH_USER}@${SERVER_IP}" "dotnet --list-runtimes 2>/dev/null | grep -q '^Microsoft.NETCore.App 9\\.'"; then
              echo "dotnet 9 runtime: OK"
            else
              echo "dotnet 9 runtime: INSTALL"
              ssh $SSH_OPTS "${SSH_USER}@${SERVER_IP}" /bin/bash -lc '
                set -Eeuo pipefail
                if ! dpkg -s packages-microsoft-prod >/dev/null 2>&1; then
                  . /etc/os-release
                  UBU="${VERSION_ID:-22.04}"
                  URL="https://packages.microsoft.com/config/ubuntu/${UBU}/packages-microsoft-prod.deb"
                  curl -fsSL "$URL" -o /tmp/ms.deb || curl -fsSL "https://packages.microsoft.com/config/ubuntu/22.04/packages-microsoft-prod.deb" -o /tmp/ms.deb
                  sudo dpkg -i /tmp/ms.deb
                  rm -f /tmp/ms.deb
                fi
                sudo apt-get update -y
                sudo apt-get install -y dotnet-runtime-9.0
              '
              ssh $SSH_OPTS "${SSH_USER}@${SERVER_IP}" "dotnet --list-runtimes | grep -q '^Microsoft.NETCore.App 9\\.'"
              echo "dotnet 9 runtime: INSTALLED"
            fi
          '''
        }
      }
    }

    stage('Deploy via SSH') {
      steps {
        script {
          // Генерируем "безопасное" имя для папки и сервиса на основе ветки и репозитория
          SAFE_BRANCH = "${params.BRANCH}".replaceAll('/', '_').replaceAll(' ', '_').replaceAll('[^A-Za-z0-9._-]', '')
          // Формируем конечный путь на сервере и имя сервиса
          DEST_PATH = "/opt/${REPO_NAME}/${SAFE_BRANCH}"
          SERVICE_NAME = "ss14-${REPO_NAME}-${SAFE_BRANCH}.service"
        }
        withCredentials([sshUserPrivateKey(credentialsId: params.SSH_CREDENTIALS_ID, keyFileVariable: 'SSH_KEY', usernameVariable: 'SSH_USER')]) {
          sh """#!/usr/bin/env bash
            set -Eeuo pipefail
            SSH_OPTS="-o StrictHostKeyChecking=no -o ServerAliveInterval=30 -o ServerAliveCountMax=120 -i \"$SSH_KEY\""

            # Создаем целевую директорию
            ssh $SSH_OPTS "${SSH_USER}@${SERVER_IP}" "sudo mkdir -p '${DEST_PATH}/logs' && sudo chown -R ${SSH_USER}:${SSH_USER} '${DEST_PATH}'"

            # Открываем порт из конфига в фаерволе
            if ssh $SSH_OPTS "${SSH_USER}@${SERVER_IP}" "command -v ufw >/dev/null 2>&1"; then
              ssh $SSH_OPTS "${SSH_USER}@${SERVER_IP}" "sudo ufw allow ${PORT}/tcp || true; sudo ufw allow ${PORT}/udp || true"
            elif ssh $SSH_OPTS "${SSH_USER}@${SERVER_IP}" "command -v firewall-cmd >/dev/null 2>&1"; then
              ssh $SSH_OPTS "${SSH_USER}@${SERVER_IP}" "sudo firewall-cmd --permanent --add-port=${PORT}/tcp || true; sudo firewall-cmd --permanent --add-port=${PORT}/udp || true; sudo firewall-cmd --reload || true"
            else
              ssh $SSH_OPTS "${SSH_USER}@${SERVER_IP}" "sudo iptables -I INPUT -p tcp --dport ${PORT} -j ACCEPT || true; sudo iptables -I INPUT -p udp --dport ${PORT} -j ACCEPT || true"
            fi

            # Загружаем бинарники (ИСКЛЮЧАЯ конфиг, чтобы его не перезатереть)
            rsync -a --delete --exclude 'server_config.toml' --exclude 'data/' -e "ssh $SSH_OPTS" artifact/ "${SSH_USER}@${SERVER_IP}:${DEST_PATH}/"

            # Загружаем наш подготовленный конфиг
            scp $SSH_OPTS server_config.toml "${SSH_USER}@${SERVER_IP}:${DEST_PATH}/server_config.toml"

            # Создаем и загружаем systemd unit файл
            cat > "${SERVICE_NAME}" << 'EOF'
[Unit]
Description=SS14 ${SAFE_BRANCH} server (${REPO_NAME})
After=network-online.target
Wants=network-online.target

[Service]
User=${SSH_USER}
Group=${SSH_USER}
WorkingDirectory=${DEST_PATH}
ExecStart=${DEST_PATH}/Robust.Server
Restart=always
RestartSec=3
Environment=DOTNET_TieredPGO=1
Environment=DOTNET_TC_QuickJitForLoops=1
Environment=ROBUST_NUMERICS_AVX=true

[Install]
WantedBy=multi-user.target
EOF

            scp $SSH_OPTS "${SERVICE_NAME}" "${SSH_USER}@${SERVER_IP}:/tmp/${SERVICE_NAME}"
            ssh $SSH_OPTS "${SSH_USER}@${SERVER_IP}" "
              sudo mv /tmp/${SERVICE_NAME} /etc/systemd/system/${SERVICE_NAME} &&
              sudo systemctl daemon-reload &&
              sudo systemctl enable ${SERVICE_NAME} || true &&
              sudo systemctl restart ${SERVICE_NAME}
            "

            # Проверяем запуск
            echo "Deployment complete. Waiting for service to start..."
            sleep 15

            ssh $SSH_OPTS "${SSH_USER}@${SERVER_IP}" /bin/bash -lc '
              set -e
              # Проверяем, что сервис активен
              if ! sudo systemctl is-active --quiet '"${SERVICE_NAME}"'; then
                echo "❌ Service is not active!"
                sudo journalctl -u '"${SERVICE_NAME}"' -n 50 --no-pager
                exit 1
              fi

              # Проверяем, что сокет слушает нужный порт
              for i in {1..10}; do
                if ss -lntu | grep -q ":${PORT}"; then
                  echo "✅ Port ${PORT} is open."
                  break
                fi
                sleep 3
              done

              # Пытаемся получить /info (ждем пока сервер полностью инициализируется)
              INFO_URL="http://127.0.0.1:${PORT}/info"
              for i in {1..20}; do
                if curl -s --max-time 5 "$INFO_URL" > /tmp/server_info.json; then
                  echo "✅ Server responded to /info."
                  break
                fi
                sleep 5
              done

              # Пытаемся распарсить и показать информацию о сервере
              if [ -f /tmp/server_info.json ]; then
                echo "--- Server Info ---"
                jq -r '"".desc           : \"\(.desc // \"unknown\")\"\\n.build.version   : \"\(.build.version // \"unknown\")\"\\n.build.engine_version: \"\(.build.engine_version // \"unknown\")\"\\n.build.fork_id    : \"\(.build.fork_id // \"unknown\")\"""' /tmp/server_info.json 2>/dev/null || cat /tmp/server_info.json
              else
                echo "⚠️  Could not fetch server info, but service is running."
              fi

              echo "--- Connection Info ---"
              echo "Connect via IP:   ss14://${SERVER_IP}:${PORT}"
              # Пытаемся получить server_url из конфига для красивого домена
              SERVER_URL=$(awk -F= '"'/^[[:space:]]*server_url[[:space:]]*=/ { gsub(/[ \\t"\\047]/, "", $2); print $2; exit }'"' '"${DEST_PATH}/server_config.toml"' 2>/dev/null || true)
              if [ -n "$SERVER_URL" ]; then
                echo "Connect via URL:  $SERVER_URL"
              fi
            '
          """
        }
      }
    }
  }

  post {
    always {
      archiveArtifacts artifacts: 'msbuild-logs/**', allowEmptyArchive: true
    }
    success {
      echo "✅ Deploy completed successfully."
      echo "Server should be available at: ss14://${params.SERVER_IP}:${PORT}"
    }
    failure {
      echo "❌ Deploy failed."
    }
  }
}
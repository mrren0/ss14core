pipeline {
  agent any
  options { timestamps(); ansiColor('xterm'); durabilityHint('PERFORMANCE_OPTIMIZED'); timeout(time: 90, unit: 'MINUTES') }

  parameters {
    string(name: 'BRANCH', defaultValue: 'master', description: 'Ветка деплоя')
    string(name: 'REPO',   defaultValue: 'https://github.com/thunder-ss14/corporate-war.git', description: 'Git repo (https или ssh)')
    string(name: 'TARGET', defaultValue: '162.19.232.192', description: 'IP/host; также credentialsId')
    file  (name: 'CFG_FILE', description: 'Загрузи config-server.toml')
    text  (name: 'CFG_FULL', defaultValue: '', description: 'Альтернатива: вставь целиком TOML')
    booleanParam(name: 'FORCE_CONFIG', defaultValue: true, description: 'Перезаписывать server_config.toml')
  }

  environment {
    DOTNET_CLI_TELEMETRY_OPTOUT = '1'
    GIT_TERMINAL_PROMPT = '0'
    MSBUILDDISABLENODEREUSE = '1'
    DOTNET_CLI_HOME = "${WORKSPACE}/.dotnet_home"
    MSBUILDDEBUGPATH = "${WORKSPACE}/msbuild-logs"
  }

  stages {
    stage('Checkout + Submodules') {
      steps {
        withCredentials([string(credentialsId: 'token-github', variable: 'GITHUB_TOKEN')]) {
          sh '''#!/usr/bin/env bash
set -euo pipefail
rm -rf src
cat > askpass.sh <<'EOS'
#!/bin/sh
case "$1" in
  *Username*) echo "x-access-token" ;;
  *Password*) echo "$GITHUB_TOKEN" ;;
esac
EOS
chmod +x askpass.sh
GIT_ASKPASS="$PWD/askpass.sh" git clone --recursive https://github.com/thunder-ss14/corporate-war src
cd src
git checkout "${BRANCH}"
git submodule sync --recursive
GIT_ASKPASS="$PWD/../askpass.sh" git -c protocol.version=2 submodule update --init --recursive
'''
        }
      }
    }

    stage('.NET SDK (local)') {
      steps {
        sh '''#!/usr/bin/env bash
set -euo pipefail
mkdir -p .dotnet "$DOTNET_CLI_HOME" "$MSBUILDDEBUGPATH"
curl -fsSL --retry 8 --retry-all-errors --retry-delay 2 -o dotnet-install.sh https://dot.net/v1/dotnet-install.sh
bash dotnet-install.sh --install-dir "$PWD/.dotnet" --channel 9.0
export PATH="$PWD/.dotnet:$PATH"
dotnet --info
'''
      }
    }

    stage('Restore (retry)') {
      steps {
        sh '''#!/usr/bin/env bash
set -Eeuo pipefail
export PATH="$PWD/.dotnet:$PATH"
cd src
dotnet nuget locals all --clear || true
for i in 1 2 3; do
  stdbuf -oL -eL dotnet restore --no-cache && s=0 && break || s=$?
  echo "restore retry $i failed with $s"; sleep $((5*i))
done
[ "${s:-0}" -eq 0 ]
'''
      }
    }

    stage('Build & Package') {
      steps {
        retry(2) {
          sh '''#!/usr/bin/env bash
set -Eeuo pipefail
export PATH="$PWD/.dotnet:$PATH"
cd src
( while true; do echo "[keepalive] $(date -Iseconds) build alive"; sleep 55; done ) & KA=$!
trap 'kill $KA 2>/dev/null || true; dotnet build-server shutdown || true' EXIT
stdbuf -oL -eL dotnet publish Content.Server -c Release -o ../artifact
test -x ../artifact/Robust.Server
'''
        }
      }
    }

    stage('Deploy via SSH') {
      steps {
        script {
          if (params.CFG_FULL?.trim()) { writeFile file: 'cfg_full.toml', text: params.CFG_FULL }
        }
        withCredentials([sshUserPrivateKey(credentialsId: params.TARGET, keyFileVariable: 'SSH_KEY', usernameVariable: 'SSH_USER')]) {
          sh '''#!/usr/bin/env bash
set -Eeuo pipefail
: "${CFG_FILE:=}"
SSH_OPTS="-o StrictHostKeyChecking=no -o ServerAliveInterval=30 -o ServerAliveCountMax=120 -i \"$SSH_KEY\""
esc() { printf '%s' "$1" | sed -e 's/\\\\/\\\\\\\\/g' -e 's/"/\\\\\\"/g'; }

# выбрать источник конфига: файл > CFG_FULL
CFG_SRC=""
if [ -n "$CFG_FILE" ]; then
  [ -f "$WORKSPACE/$CFG_FILE" ] && CFG_SRC="$WORKSPACE/$CFG_FILE"
  [ -z "$CFG_SRC" ] && [ -f "$CFG_FILE" ] && CFG_SRC="$CFG_FILE"
fi
[ -z "$CFG_SRC" ] && [ -f "$WORKSPACE/cfg_full.toml" ] && CFG_SRC="$WORKSPACE/cfg_full.toml"
if [ -z "$CFG_SRC" ]; then
  echo "No config provided: upload CFG_FILE or fill CFG_FULL" >&2
  exit 2
fi

# порт из выбранного конфига
PORT_FROM_CFG="$(awk -F= '/^[[:space:]]*port[[:space:]]*=/{ sub(/#.*/,""); gsub(/[[:space:]]/,"",$2); print $2; exit }' "$CFG_SRC")"
: "${PORT:=${PORT_FROM_CFG:-1212}}"

repo_path="$(printf '%s' "${REPO}" | sed -E 's#(git@github.com:|https://github.com/)([^/]+)/([^/.]+)(\\.git)?#\\2/\\3#')"
owner="${repo_path%/*}"
repo="${repo_path##*/}"
safe_branch="$(printf '%s' "${BRANCH}" | tr -c 'a-zA-Z0-9._-' '_')"
DEST="/opt/${owner}/${repo}/${safe_branch}"
UNIT="ss14@${safe_branch}.service"

# ensure dest
ssh $SSH_OPTS "${SSH_USER}@${TARGET}" "sudo mkdir -p '${DEST}' '${DEST}/logs' '${DEST}/data' && sudo chown -R ${SSH_USER}:${SSH_USER} '${DEST}'"

# firewall
if ssh $SSH_OPTS "${SSH_USER}@${TARGET}" "command -v ufw >/dev/null 2>&1"; then
  ssh $SSH_OPTS "${SSH_USER}@${TARGET}" "sudo ufw allow ${PORT}/tcp || true; sudo ufw allow ${PORT}/udp || true"
elif ssh $SSH_OPTS "${SSH_USER}@${TARGET}" "command -v firewall-cmd >/dev/null 2>&1"; then
  ssh $SSH_OPTS "${SSH_USER}@${TARGET}" "sudo firewall-cmd --permanent --add-port=${PORT}/tcp || true; sudo firewall-cmd --permanent --add-port=${PORT}/udp || true; sudo firewall-cmd --reload || true"
else
  ssh $SSH_OPTS "${SSH_USER}@${TARGET}" "sudo iptables -I INPUT -p tcp --dport ${PORT} -j ACCEPT || true; sudo iptables -I INPUT -p udp --dport ${PORT} -j ACCEPT || true"
fi

# upload binaries
rsync -a --delete --exclude 'server_config.toml' --exclude 'data' -e "ssh $SSH_OPTS" artifact/ "${SSH_USER}@${TARGET}:${DEST}/"

# config
tmpdir="$(mktemp -d)"; cfg="$tmpdir/server_config.toml"
cp "$CFG_SRC" "$cfg"

# systemd unit
unit_local="$tmpdir/${UNIT}"
cat >"$unit_local" <<EOF
[Unit]
Description=SS14 ${safe_branch} server
After=network-online.target
Wants=network-online.target

[Service]
User=${SSH_USER}
Group=${SSH_USER}
WorkingDirectory=${DEST}
ExecStart=${DEST}/Robust.Server
Restart=always
RestartSec=3
StandardOutput=append:${DEST}/logs/server.log
StandardError=append:${DEST}/logs/server.err

[Install]
WantedBy=multi-user.target
EOF

# push config + unit
if [ "${FORCE_CONFIG:-true}" = "true" ]; then
  rsync -a -e "ssh $SSH_OPTS" "$cfg" "${SSH_USER}@${TARGET}:${DEST}/server_config.toml"
fi
scp $SSH_OPTS "$unit_local" "${SSH_USER}@${TARGET}:/tmp/${UNIT}"
ssh $SSH_OPTS "${SSH_USER}@${TARGET}" "sudo mv /tmp/${UNIT} /etc/systemd/system/${UNIT}"

# enable + restart
ssh $SSH_OPTS "${SSH_USER}@${TARGET}" "sudo systemctl daemon-reload && sudo systemctl enable ${UNIT} --now && sudo systemctl restart ${UNIT} && systemctl status ${UNIT} --no-pager || true"
ssh $SSH_OPTS "${SSH_USER}@${TARGET}" "pgrep -af Robust.Server || pgrep -af Content.Server || true"
'''
        }
      }
    }
  }

  post {
    success { echo 'DONE' }
    failure { echo 'FAILED' }
    always  { echo 'END' }
  }
}
